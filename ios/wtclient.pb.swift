// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: wtclient.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Wtclientrpc_AddTowerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifying public key of the watchtower to add.
  var pubkey: Data = SwiftProtobuf.Internal.emptyData

  /// A network address the watchtower is reachable over.
  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_AddTowerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_RemoveTowerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifying public key of the watchtower to remove.
  var pubkey: Data = SwiftProtobuf.Internal.emptyData

  ///
  ///If set, then the record for this address will be removed, indicating that is
  ///is stale. Otherwise, the watchtower will no longer be used for future
  ///session negotiations and backups.
  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_RemoveTowerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_GetTowerInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifying public key of the watchtower to retrieve information for.
  var pubkey: Data = SwiftProtobuf.Internal.emptyData

  /// Whether we should include sessions with the watchtower in the response.
  var includeSessions: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_TowerSession {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The total number of successful backups that have been made to the
  ///watchtower session.
  var numBackups: UInt32 = 0

  ///
  ///The total number of backups in the session that are currently pending to be
  ///acknowledged by the watchtower.
  var numPendingBackups: UInt32 = 0

  /// The maximum number of backups allowed by the watchtower session.
  var maxBackups: UInt32 = 0

  ///
  ///The fee rate, in satoshis per vbyte, that will be used by the watchtower for
  ///the justice transaction in the event of a channel breach.
  var sweepSatPerByte: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_Tower {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifying public key of the watchtower.
  var pubkey: Data = SwiftProtobuf.Internal.emptyData

  /// The list of addresses the watchtower is reachable over.
  var addresses: [String] = []

  /// Whether the watchtower is currently a candidate for new sessions.
  var activeSessionCandidate: Bool = false

  /// The number of sessions that have been negotiated with the watchtower.
  var numSessions: UInt32 = 0

  /// The list of sessions that have been negotiated with the watchtower.
  var sessions: [Wtclientrpc_TowerSession] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_ListTowersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether we should include sessions with the watchtower in the response.
  var includeSessions: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_ListTowersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of watchtowers available for new backups.
  var towers: [Wtclientrpc_Tower] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_StatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_StatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The total number of backups made to all active and exhausted watchtower
  ///sessions.
  var numBackups: UInt32 = 0

  ///
  ///The total number of backups that are pending to be acknowledged by all
  ///active and exhausted watchtower sessions.
  var numPendingBackups: UInt32 = 0

  ///
  ///The total number of backups that all active and exhausted watchtower
  ///sessions have failed to acknowledge.
  var numFailedBackups: UInt32 = 0

  /// The total number of new sessions made to watchtowers.
  var numSessionsAcquired: UInt32 = 0

  /// The total number of watchtower sessions that have been exhausted.
  var numSessionsExhausted: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_PolicyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_PolicyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The maximum number of updates each session we negotiate with watchtowers
  ///should allow.
  var maxUpdates: UInt32 = 0

  ///
  ///The fee rate, in satoshis per vbyte, that will be used by watchtowers for
  ///justice transactions in response to channel breaches.
  var sweepSatPerByte: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "wtclientrpc"

extension Wtclientrpc_AddTowerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddTowerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubkey"),
    2: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.pubkey)
      case 2: try decoder.decodeSingularStringField(value: &self.address)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubkey, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_AddTowerRequest, rhs: Wtclientrpc_AddTowerRequest) -> Bool {
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_AddTowerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddTowerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_AddTowerResponse, rhs: Wtclientrpc_AddTowerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_RemoveTowerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveTowerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubkey"),
    2: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.pubkey)
      case 2: try decoder.decodeSingularStringField(value: &self.address)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubkey, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_RemoveTowerRequest, rhs: Wtclientrpc_RemoveTowerRequest) -> Bool {
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_RemoveTowerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveTowerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_RemoveTowerResponse, rhs: Wtclientrpc_RemoveTowerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_GetTowerInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTowerInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubkey"),
    2: .same(proto: "include_sessions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.pubkey)
      case 2: try decoder.decodeSingularBoolField(value: &self.includeSessions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubkey, fieldNumber: 1)
    }
    if self.includeSessions != false {
      try visitor.visitSingularBoolField(value: self.includeSessions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_GetTowerInfoRequest, rhs: Wtclientrpc_GetTowerInfoRequest) -> Bool {
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.includeSessions != rhs.includeSessions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_TowerSession: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TowerSession"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "num_backups"),
    2: .same(proto: "num_pending_backups"),
    3: .same(proto: "max_backups"),
    4: .same(proto: "sweep_sat_per_byte"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.numBackups)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.numPendingBackups)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.maxBackups)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.sweepSatPerByte)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numBackups != 0 {
      try visitor.visitSingularUInt32Field(value: self.numBackups, fieldNumber: 1)
    }
    if self.numPendingBackups != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPendingBackups, fieldNumber: 2)
    }
    if self.maxBackups != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxBackups, fieldNumber: 3)
    }
    if self.sweepSatPerByte != 0 {
      try visitor.visitSingularUInt32Field(value: self.sweepSatPerByte, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_TowerSession, rhs: Wtclientrpc_TowerSession) -> Bool {
    if lhs.numBackups != rhs.numBackups {return false}
    if lhs.numPendingBackups != rhs.numPendingBackups {return false}
    if lhs.maxBackups != rhs.maxBackups {return false}
    if lhs.sweepSatPerByte != rhs.sweepSatPerByte {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_Tower: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Tower"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubkey"),
    2: .same(proto: "addresses"),
    3: .same(proto: "active_session_candidate"),
    4: .same(proto: "num_sessions"),
    5: .same(proto: "sessions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.pubkey)
      case 2: try decoder.decodeRepeatedStringField(value: &self.addresses)
      case 3: try decoder.decodeSingularBoolField(value: &self.activeSessionCandidate)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.numSessions)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.sessions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubkey, fieldNumber: 1)
    }
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 2)
    }
    if self.activeSessionCandidate != false {
      try visitor.visitSingularBoolField(value: self.activeSessionCandidate, fieldNumber: 3)
    }
    if self.numSessions != 0 {
      try visitor.visitSingularUInt32Field(value: self.numSessions, fieldNumber: 4)
    }
    if !self.sessions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sessions, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_Tower, rhs: Wtclientrpc_Tower) -> Bool {
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.addresses != rhs.addresses {return false}
    if lhs.activeSessionCandidate != rhs.activeSessionCandidate {return false}
    if lhs.numSessions != rhs.numSessions {return false}
    if lhs.sessions != rhs.sessions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_ListTowersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTowersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "include_sessions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.includeSessions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.includeSessions != false {
      try visitor.visitSingularBoolField(value: self.includeSessions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_ListTowersRequest, rhs: Wtclientrpc_ListTowersRequest) -> Bool {
    if lhs.includeSessions != rhs.includeSessions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_ListTowersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTowersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "towers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.towers)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.towers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.towers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_ListTowersResponse, rhs: Wtclientrpc_ListTowersResponse) -> Bool {
    if lhs.towers != rhs.towers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_StatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_StatsRequest, rhs: Wtclientrpc_StatsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_StatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "num_backups"),
    2: .same(proto: "num_pending_backups"),
    3: .same(proto: "num_failed_backups"),
    4: .same(proto: "num_sessions_acquired"),
    5: .same(proto: "num_sessions_exhausted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.numBackups)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.numPendingBackups)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.numFailedBackups)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.numSessionsAcquired)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.numSessionsExhausted)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numBackups != 0 {
      try visitor.visitSingularUInt32Field(value: self.numBackups, fieldNumber: 1)
    }
    if self.numPendingBackups != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPendingBackups, fieldNumber: 2)
    }
    if self.numFailedBackups != 0 {
      try visitor.visitSingularUInt32Field(value: self.numFailedBackups, fieldNumber: 3)
    }
    if self.numSessionsAcquired != 0 {
      try visitor.visitSingularUInt32Field(value: self.numSessionsAcquired, fieldNumber: 4)
    }
    if self.numSessionsExhausted != 0 {
      try visitor.visitSingularUInt32Field(value: self.numSessionsExhausted, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_StatsResponse, rhs: Wtclientrpc_StatsResponse) -> Bool {
    if lhs.numBackups != rhs.numBackups {return false}
    if lhs.numPendingBackups != rhs.numPendingBackups {return false}
    if lhs.numFailedBackups != rhs.numFailedBackups {return false}
    if lhs.numSessionsAcquired != rhs.numSessionsAcquired {return false}
    if lhs.numSessionsExhausted != rhs.numSessionsExhausted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_PolicyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PolicyRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_PolicyRequest, rhs: Wtclientrpc_PolicyRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_PolicyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PolicyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "max_updates"),
    2: .same(proto: "sweep_sat_per_byte"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.maxUpdates)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.sweepSatPerByte)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxUpdates != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxUpdates, fieldNumber: 1)
    }
    if self.sweepSatPerByte != 0 {
      try visitor.visitSingularUInt32Field(value: self.sweepSatPerByte, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_PolicyResponse, rhs: Wtclientrpc_PolicyResponse) -> Bool {
    if lhs.maxUpdates != rhs.maxUpdates {return false}
    if lhs.sweepSatPerByte != rhs.sweepSatPerByte {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
